import { randomBytes } from 'crypto';

import fetch, { type RequestInit, type Response } from 'node-fetch';

/**
 * The delay, in milliseconds, between attempts.
 */
const retryDelay = 2e3;
/**
 * The maximum number of attempts per request. `3` means: one initial attempt + up to two retries.
 */
const attemptLimit = 3;
/**
 * A set of the methods which are not idempotent by nature, specifically `POST` and `DELETE`.
 */
const unsafeMethods = new Set<string>(['DELETE', 'POST']);

/**
 * The name of the header generated by `generateIdempotencyHeader`.
 */
export const idempotencyHeaderName = 'Idempotency-Key';

/**
 * Returns an object with a single property, whose value is a random 24-character string.
 * The property's name is defined using the const `idempotencyHeaderName`.
 *
 * As the data encoded in said string is 144 bits long, the odds of two generated keys colliding is ±2% after
 * generating a sextillion (1000 billion billion, or 10^21) keys.
 */
function generateIdempotencyHeader() {
  return { [idempotencyHeaderName]: randomBytes(18).toString('base64') };
}

/**
 * Parses the 'Retry-After' header, if any, and returns the time in milliseconds. Returns `undefined` if the header is
 * not present or not parseable into a numeric value.
 *
 * If the header contains an HTTP date rather than a delay, it will be ignored.
 * @see https://httpwg.org/specs/rfc9110.html#field.retry-after
 */
function parseRetryAfterHeader(response: fetch.Response): number | undefined {
  // (If the header does not exist, the input of parseInt will be undefined, resulting in NaN. The non-null assertion
  // is thus safe.)
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  const retryAfter = parseInt(response.headers.get('retry-after')!, 10);
  if (isNaN(retryAfter)) {
    return undefined;
  }
  // Convert the header value from seconds to milliseconds.
  return retryAfter * 1e3;
}

export type ResponseWithIdempotencyKey = Response & { idempotencyKey: string | undefined };

/**
 * Wrapper around fetch, making it attempt requests multiple times in some scenarios.
 *
 * The idea is that if the Mollie API has a brief hiccup, the extra attempts may cause the request to succeed anyway.
 *
 * If the Mollie API responds with a 5×× status code, the request will be re-attempted until:
 *  * the Mollie API responds with a different status code, or
 *  * the attempt limit has been reached (it gives up after the third attempt), or
 *  * the request has timed out.
 *
 * For `POST` and `DELETE` requests, an idempotency key is added. This ensures the Mollie API can distinguish a single
 * request being re-attempted from two separate similarly-looking requests. In effect, this allows this client to
 * safely re-attempt requests.
 */
export function retryingFetch(originalFetch: typeof fetch) {
  return async function fetchWithRetries(input: string, init: RequestInit): Promise<ResponseWithIdempotencyKey> {
    // If the request is a POST or DELETE one and does not yet have the idempotency header, add one now.
    if (init.method != undefined && unsafeMethods.has(init.method.toUpperCase()) && init.headers && !(idempotencyHeaderName in init.headers)) {
      init.headers = { ...init.headers, ...generateIdempotencyHeader() };
    }
    // Attempt the request.
    for (let attempt = 0; ; ++attempt) {
      const response = await originalFetch(input, init).then(response =>
        Object.assign(response, { idempotencyKey: init.headers && idempotencyHeaderName in init.headers ? (init.headers[idempotencyHeaderName] as string) : undefined }),
      );
      // If this is the last attempt, return the response.
      if (attempt === attemptLimit - 1) {
        return response;
      }
      // If the response is not a 5×× status code, return it.
      if (Math.floor(response.status / 100) != 5) {
        return response;
      }
      // Determine the delay after which the next attempt is made, preferring a Retry-After header defined in the
      // response over the default value.
      const delay = parseRetryAfterHeader(response) ?? retryDelay;
      // Wait before the next attempt.
      await sleep(delay);
    }
  };
}

function sleep(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
